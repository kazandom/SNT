/******************************************************************************/
/***         Generated by IBExpert 2019.2.14.1 15.05.2019 18:03:26          ***/
/******************************************************************************/

/******************************************************************************/
/***                                Domains                                 ***/
/******************************************************************************/



/******************************************************************************/
/***                               Exceptions                               ***/
/******************************************************************************/

CREATE EXCEPTION RASCHET_EXCEPTION '';

CREATE EXCEPTION POKAZANIE_EXCEPTION '';

CREATE EXCEPTION PERIOD_EXCEPTION '';

CREATE EXCEPTION PARAMETR_EXCEPTION '';

/******************************************************************************/
/***                               Procedures                               ***/
/******************************************************************************/

SET TERM ^ ;

SET TERM ; ^



/******************************************************************************/
/***                            Tables and Views                            ***/
/******************************************************************************/

CREATE TABLE NACHISLENIE (
    ID_UCHASTOK INTEGER NOT NULL,
    ID_SERVICE INTEGER NOT NULL,
    PERIOD SMALLINT NOT NULL CHECK (PERIOD SIMILAR TO '[1-2][0-9][0-9][0-9]'),
    IZMENENIE DECIMAL(18,2) DEFAULT 0 NOT NULL,
    NACHIS DECIMAL(18,2) DEFAULT 0 NOT NULL CHECK (NACHIS >= 0),
    K_OPLATE COMPUTED BY (NACHIS + IZMENENIE));


/* DatabaseDesigner Table PostScript - IDENTITY ColumnType */
ALTER TABLE NACHISLENIE
    ADD ID BIGINT GENERATED BY DEFAULT AS IDENTITY,
    ALTER ID POSITION 1;

CREATE TABLE OPLATA (
    ID_UCHASTOK INTEGER NOT NULL,
    SUMMA DECIMAL(18,2) NOT NULL CHECK (SUMMA >= 0),
    PERIOD SMALLINT NOT NULL CHECK (PERIOD SIMILAR TO '[1-2][0-9][0-9][0-9]'),
    DATA_ DATE NOT NULL);


/* DatabaseDesigner Table PostScript - IDENTITY ColumnType */
ALTER TABLE OPLATA
    ADD ID INTEGER GENERATED BY DEFAULT AS IDENTITY,
    ALTER ID POSITION 1;

CREATE TABLE PARAM_GLOBAL (
    ID_PARAMETR INTEGER NOT NULL,
    NACHALO SMALLINT NOT NULL CHECK (NACHALO SIMILAR TO '[1-2][0-9][0-9][0-9]'),
    ZNACHENIE DECIMAL(9,3) NOT NULL,
    CHANGED DATE NOT NULL,
    NOTE VARCHAR(3000));


/* DatabaseDesigner Table PostScript - IDENTITY ColumnType */
ALTER TABLE PARAM_GLOBAL
    ADD ID INTEGER GENERATED BY DEFAULT AS IDENTITY,
    ALTER ID POSITION 1;

CREATE TABLE PARAM_UCH (
    ID_UCHASTOK INTEGER NOT NULL,
    ID_PARAMETR INTEGER NOT NULL,
    NACHALO SMALLINT NOT NULL CHECK (NACHALO SIMILAR TO '[1-2][0-9][0-9][0-9]'),
    ZNACHENIE DECIMAL(9,3) NOT NULL,
    CHANGED DATE NOT NULL,
    NOTE VARCHAR(3000));


/* DatabaseDesigner Table PostScript - IDENTITY ColumnType */
ALTER TABLE PARAM_UCH
    ADD ID INTEGER GENERATED BY DEFAULT AS IDENTITY,
    ALTER ID POSITION 1;

CREATE TABLE PARAMETR (
    NAME VARCHAR(50) NOT NULL,
    GLOBAL_ BOOLEAN DEFAULT FALSE NOT NULL);


/* DatabaseDesigner Table PostScript - IDENTITY ColumnType */
ALTER TABLE PARAMETR
    ADD ID INTEGER GENERATED BY DEFAULT AS IDENTITY,
    ALTER ID POSITION 1;

CREATE TABLE PERIOD_SELECTION (
    PERIOD SMALLINT NOT NULL CHECK (PERIOD SIMILAR TO '[1-2][0-9][0-9][0-9]'),
    OPERATING BOOLEAN DEFAULT FALSE NOT NULL);


CREATE TABLE POKAZANIE (
    ID_SCHETCHIK INTEGER NOT NULL,
    POKAZ DECIMAL(9,2) DEFAULT 0 NOT NULL CHECK (POKAZ >= 0),
    PERIOD SMALLINT NOT NULL CHECK (PERIOD SIMILAR TO '[1-2][0-9][0-9][0-9]'));


/* DatabaseDesigner Table PostScript - IDENTITY ColumnType */
ALTER TABLE POKAZANIE
    ADD ID INTEGER GENERATED BY DEFAULT AS IDENTITY,
    ALTER ID POSITION 1;

CREATE TABLE REKVIZITY (
    NAZVANIE VARCHAR(100) NOT NULL,
    PREDSEDATEL VARCHAR(50),
    BUHGALTER VARCHAR(50),
    INN VARCHAR(15),
    KPP VARCHAR(15),
    BANK VARCHAR(100),
    BIK VARCHAR(10),
    KORRES_SCHET VARCHAR(25),
    RASCH_SCHET VARCHAR(25));


CREATE TABLE SCHETCHIK (
    ID_UCHASTOK INTEGER NOT NULL,
    ID_SERVICE INTEGER NOT NULL,
    N VARCHAR(25) NOT NULL,
    PERV_POKAZ DECIMAL(9,2) DEFAULT 0 NOT NULL CHECK (PERV_POKAZ >= 0),
    NACHALO SMALLINT NOT NULL CHECK (NACHALO SIMILAR TO '[1-2][0-9][0-9][0-9]'),
    KONEC SMALLINT CHECK (KONEC SIMILAR TO '[1-2][0-9][0-9][0-9]' AND KONEC >= NACHALO));


/* DatabaseDesigner Table PostScript - IDENTITY ColumnType */
ALTER TABLE SCHETCHIK
    ADD ID INTEGER GENERATED BY DEFAULT AS IDENTITY,
    ALTER ID POSITION 1;

CREATE TABLE SERV_UCH_DISABLE (
    ID_UCHASTOK INTEGER NOT NULL,
    ID_SERVICE INTEGER NOT NULL,
    NACHALO SMALLINT NOT NULL CHECK (NACHALO SIMILAR TO '[1-2][0-9][0-9][0-9]'),
    DISABLE BOOLEAN NOT NULL,
    CHANGED DATE NOT NULL,
    NOTE VARCHAR(3000));


/* DatabaseDesigner Table PostScript - IDENTITY ColumnType */
ALTER TABLE SERV_UCH_DISABLE
    ADD ID INTEGER GENERATED BY DEFAULT AS IDENTITY,
    ALTER ID POSITION 1;

CREATE TABLE SERVICE (
    NAME VARCHAR(50) NOT NULL,
    NACHALO SMALLINT NOT NULL CHECK (NACHALO SIMILAR TO '[1-2][0-9][0-9][0-9]'),
    KONEC SMALLINT CHECK (KONEC SIMILAR TO '[1-2][0-9][0-9][0-9]' AND KONEC >= NACHALO),
    SCHETCHIK_ BOOLEAN DEFAULT FALSE NOT NULL,
    S_UCH BOOLEAN DEFAULT FALSE NOT NULL,
    ID_PARAMETR_1 INTEGER,
    ID_PARAMETR_2 INTEGER CHECK ((ID_PARAMETR_1 IS NULL AND ID_PARAMETR_2 IS NULL) OR  (ID_PARAMETR_1 IS NOT NULL AND ID_PARAMETR_2 IS NULL) OR (ID_PARAMETR_1 IS NOT NULL AND ID_PARAMETR_2 IS NOT NULL)),
    ID_PARAMETR_3 INTEGER CHECK ((ID_PARAMETR_2 IS NULL AND ID_PARAMETR_3 IS NULL) OR  (ID_PARAMETR_2 IS NOT NULL AND ID_PARAMETR_3 IS NULL) OR (ID_PARAMETR_2 IS NOT NULL AND ID_PARAMETR_3 IS NOT NULL)),
    ID_PARAMETR_4 INTEGER CHECK ((ID_PARAMETR_3 IS NULL AND ID_PARAMETR_4 IS NULL) OR  (ID_PARAMETR_3 IS NOT NULL AND ID_PARAMETR_4 IS NULL) OR (ID_PARAMETR_3 IS NOT NULL AND ID_PARAMETR_4 IS NOT NULL)),
    OPERATOR_1 SMALLINT DEFAULT 1 NOT NULL CHECK (OPERATOR_1 = 1 OR OPERATOR_1 = 2 OR OPERATOR_1 = 3 OR OPERATOR_1 = 4),
    OPERATOR_2 SMALLINT DEFAULT 1 NOT NULL CHECK (OPERATOR_2 = 1 OR OPERATOR_2 = 2 OR OPERATOR_2 = 3 OR OPERATOR_2 = 4),
    OPERATOR_3 SMALLINT DEFAULT 1 NOT NULL CHECK (OPERATOR_3 = 1 OR OPERATOR_3 = 2 OR OPERATOR_3 = 3 OR OPERATOR_3 = 4),
    OPERATOR_4 SMALLINT DEFAULT 1 NOT NULL CHECK (OPERATOR_4 = 1 OR OPERATOR_4 = 2 OR OPERATOR_4 = 3 OR OPERATOR_4 = 4));


/* DatabaseDesigner Table PostScript - IDENTITY ColumnType */
ALTER TABLE SERVICE
    ADD ID INTEGER GENERATED BY DEFAULT AS IDENTITY,
    ALTER ID POSITION 1;

CREATE TABLE SOBSTV_UCH (
    ID_SOBSTVENNIK INTEGER NOT NULL,
    ID_UCHASTOK INTEGER NOT NULL,
    DOLYA VARCHAR(10) DEFAULT 1,
    DOCUMENT VARCHAR(100),
    DATA_IN DATE NOT NULL,
    DATA_OUT DATE CHECK (DATA_OUT > DATA_IN));


/* DatabaseDesigner Table PostScript - IDENTITY ColumnType */
ALTER TABLE SOBSTV_UCH
    ADD ID INTEGER GENERATED BY DEFAULT AS IDENTITY,
    ALTER ID POSITION 1;

CREATE TABLE SOBSTVENNIK (
    FAMILIYA VARCHAR(25) NOT NULL,
    IMYA VARCHAR(25),
    OTCHESTVO VARCHAR(25),
    PHONE VARCHAR(25),
    EMAIL VARCHAR(25),
    ADDRESS VARCHAR(100));


/* DatabaseDesigner Table PostScript - IDENTITY ColumnType */
ALTER TABLE SOBSTVENNIK
    ADD ID INTEGER GENERATED BY DEFAULT AS IDENTITY,
    ALTER ID POSITION 1;

CREATE TABLE TARIF (
    ID_SERVICE INTEGER NOT NULL,
    NACHALO SMALLINT NOT NULL CHECK (NACHALO SIMILAR TO '[1-2][0-9][0-9][0-9]'),
    ZNACHENIE DECIMAL(9,2) NOT NULL,
    CHANGED DATE NOT NULL,
    NOTE VARCHAR(3000));


/* DatabaseDesigner Table PostScript - IDENTITY ColumnType */
ALTER TABLE TARIF
    ADD ID INTEGER GENERATED BY DEFAULT AS IDENTITY,
    ALTER ID POSITION 1;

CREATE TABLE UCHASTOK (
    N VARCHAR(7) NOT NULL,
    ALLEYA VARCHAR(50),
    S DECIMAL(9,2) NOT NULL CHECK (S >= 0),
    KADASTR VARCHAR(25),
    NACHALO SMALLINT NOT NULL CHECK (NACHALO SIMILAR TO '[1-2][0-9][0-9][0-9]'),
    KONEC SMALLINT CHECK (KONEC SIMILAR TO '[1-2][0-9][0-9][0-9]' AND KONEC >= NACHALO));


/* DatabaseDesigner Table PostScript - IDENTITY ColumnType */
ALTER TABLE UCHASTOK
    ADD ID INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 10000000),
    ALTER ID POSITION 1;



/******************************************************************************/
/***                              Primary keys                              ***/
/******************************************************************************/


ALTER TABLE NACHISLENIE ADD CONSTRAINT PK_NACHISLENIE PRIMARY KEY (ID);
ALTER TABLE OPLATA ADD CONSTRAINT PK_OPLATA PRIMARY KEY (ID);
ALTER TABLE PARAM_GLOBAL ADD CONSTRAINT PK_PARAM_GLOBAL PRIMARY KEY (ID);
ALTER TABLE PARAM_UCH ADD CONSTRAINT PK_PARAM_UCH PRIMARY KEY (ID);
ALTER TABLE PARAMETR ADD CONSTRAINT PK_PARAMETR PRIMARY KEY (ID);
ALTER TABLE PERIOD_SELECTION ADD CONSTRAINT PK_PERIOD_SELECTION PRIMARY KEY (PERIOD);
ALTER TABLE POKAZANIE ADD CONSTRAINT PK_POKAZANIE PRIMARY KEY (ID);
ALTER TABLE REKVIZITY ADD CONSTRAINT PK_REKVIZITY PRIMARY KEY (NAZVANIE);
ALTER TABLE SCHETCHIK ADD CONSTRAINT PK_SCHETCHIK PRIMARY KEY (ID);
ALTER TABLE SERV_UCH_DISABLE ADD CONSTRAINT PK_SERV_UCH_DISABLE PRIMARY KEY (ID);
ALTER TABLE SERVICE ADD CONSTRAINT PK_SERVICE PRIMARY KEY (ID);
ALTER TABLE SOBSTV_UCH ADD CONSTRAINT PK_SOBSTV_UCH PRIMARY KEY (ID);
ALTER TABLE SOBSTVENNIK ADD CONSTRAINT PK_SOBSTVENNIK PRIMARY KEY (ID);
ALTER TABLE TARIF ADD CONSTRAINT PK_TARIF PRIMARY KEY (ID);
ALTER TABLE UCHASTOK ADD CONSTRAINT PK_UCHASTOK PRIMARY KEY (ID);

/******************************************************************************/
/***                           Unique constraints                           ***/
/******************************************************************************/


ALTER TABLE NACHISLENIE ADD CONSTRAINT U_NACH_ID_UCH_ID_SERV_PER UNIQUE (ID_UCHASTOK, ID_SERVICE, PERIOD);
ALTER TABLE PARAM_GLOBAL ADD CONSTRAINT U_PARAM_GLOBAL_ID_PARAM_NACH UNIQUE (ID_PARAMETR, NACHALO);
ALTER TABLE PARAM_UCH ADD CONSTRAINT U_PARAM_UCH_ID_UCH_ID_PARAM_NAC UNIQUE (ID_UCHASTOK, ID_PARAMETR, NACHALO);
ALTER TABLE PARAMETR ADD CONSTRAINT U_PARAMETR_NAME UNIQUE (NAME);
ALTER TABLE POKAZANIE ADD CONSTRAINT U_POKAZANIE_ID_SCH_PERIOD UNIQUE (ID_SCHETCHIK, PERIOD);
ALTER TABLE SCHETCHIK ADD CONSTRAINT U_SCHETCHIK_N_ID_SERV UNIQUE (N, ID_SERVICE);
ALTER TABLE SERV_UCH_DISABLE ADD CONSTRAINT U_SERV_UCH_DIS_ID_U_ID_SERV_NAC UNIQUE (ID_UCHASTOK, ID_SERVICE, NACHALO);
ALTER TABLE SERVICE ADD CONSTRAINT U_SERVICE_NAME UNIQUE (NAME);
ALTER TABLE TARIF ADD CONSTRAINT U_TARIF_ID_SERV_NACH UNIQUE (ID_SERVICE, NACHALO);
ALTER TABLE UCHASTOK ADD CONSTRAINT U_UCHASTOK_N UNIQUE (N);

/******************************************************************************/
/***                              Foreign keys                              ***/
/******************************************************************************/


ALTER TABLE NACHISLENIE ADD CONSTRAINT FK_NACHISLENIE_ID_UCH FOREIGN KEY (ID_UCHASTOK) REFERENCES UCHASTOK (ID);
ALTER TABLE NACHISLENIE ADD CONSTRAINT FK_NACHISLENIE_ID_SERV FOREIGN KEY (ID_SERVICE) REFERENCES SERVICE (ID);
ALTER TABLE OPLATA ADD CONSTRAINT FK_OPLATA_ID_UCH FOREIGN KEY (ID_UCHASTOK) REFERENCES UCHASTOK (ID);
ALTER TABLE PARAM_GLOBAL ADD CONSTRAINT FK_PARAM_GLOBAL_ID_PARAM FOREIGN KEY (ID_PARAMETR) REFERENCES PARAMETR (ID);
ALTER TABLE PARAM_UCH ADD CONSTRAINT FK_PARAM_UCH_ID_UCH FOREIGN KEY (ID_UCHASTOK) REFERENCES UCHASTOK (ID);
ALTER TABLE PARAM_UCH ADD CONSTRAINT FK_PARAM_UCH_ID_PARAM FOREIGN KEY (ID_PARAMETR) REFERENCES PARAMETR (ID);
ALTER TABLE POKAZANIE ADD CONSTRAINT FK_POKAZANIE_ID_SCH FOREIGN KEY (ID_SCHETCHIK) REFERENCES SCHETCHIK (ID);
ALTER TABLE SCHETCHIK ADD CONSTRAINT FK_SCHETCHIK_ID_UCH FOREIGN KEY (ID_UCHASTOK) REFERENCES UCHASTOK (ID);
ALTER TABLE SCHETCHIK ADD CONSTRAINT FK_SCHETCHIK_ID_SERV FOREIGN KEY (ID_SERVICE) REFERENCES SERVICE (ID);
ALTER TABLE SERV_UCH_DISABLE ADD CONSTRAINT FK_SERV_UCH_DISABLE_ID_UCH FOREIGN KEY (ID_UCHASTOK) REFERENCES UCHASTOK (ID);
ALTER TABLE SERV_UCH_DISABLE ADD CONSTRAINT FK_SERV_UCH_DISABLE_ID_SERV FOREIGN KEY (ID_SERVICE) REFERENCES SERVICE (ID);
ALTER TABLE SERVICE ADD CONSTRAINT FK_SERVICE_ID_PARAM_1 FOREIGN KEY (ID_PARAMETR_1) REFERENCES PARAMETR (ID);
ALTER TABLE SERVICE ADD CONSTRAINT FK_SERVICE_ID_PARAM_2 FOREIGN KEY (ID_PARAMETR_2) REFERENCES PARAMETR (ID);
ALTER TABLE SERVICE ADD CONSTRAINT FK_SERVICE_ID_PARAM_3 FOREIGN KEY (ID_PARAMETR_3) REFERENCES PARAMETR (ID);
ALTER TABLE SERVICE ADD CONSTRAINT FK_SERVICE_ID_PARAM_4 FOREIGN KEY (ID_PARAMETR_4) REFERENCES PARAMETR (ID);
ALTER TABLE SOBSTV_UCH ADD CONSTRAINT FK_SOBSTV_UCH_ID_UCH FOREIGN KEY (ID_UCHASTOK) REFERENCES UCHASTOK (ID);
ALTER TABLE SOBSTV_UCH ADD CONSTRAINT FK_SOBSTV_UCH_ID_SOBSTV FOREIGN KEY (ID_SOBSTVENNIK) REFERENCES SOBSTVENNIK (ID);
ALTER TABLE TARIF ADD CONSTRAINT FK_TARIF_ID_SERV FOREIGN KEY (ID_SERVICE) REFERENCES SERVICE (ID);

/******************************************************************************/
/***                           Check constraints                            ***/
/******************************************************************************/



/******************************************************************************/
/***                                Indices                                 ***/
/******************************************************************************/



/******************************************************************************/
/***                                Triggers                                ***/
/******************************************************************************/

SET TERM ^ ;

CREATE TRIGGER PARAM_GLOBAL_CHANGED FOR PARAM_GLOBAL
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  NEW.CHANGED = CURRENT_DATE ;
end

^

CREATE TRIGGER PARAM_UCH_CHANGED FOR PARAM_UCH
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  NEW.CHANGED = CURRENT_DATE ;
end

^

CREATE TRIGGER PARAMETR_CHANGE FOR PARAMETR
ACTIVE BEFORE UPDATE POSITION 0
AS
BEGIN
    IF (NEW.global_ != OLD.global_) THEN
        EXCEPTION parametr_exception 'Тип параметра "' || NEW.name || '" нельзя изменять после создания!
        ';
END

^

CREATE TRIGGER PERIOD_SELECTION_CHECK FOR PERIOD_SELECTION
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
DECLARE VARIABLE true_count BIGINT;
BEGIN
    :true_count = (SELECT COUNT(OPERATING) FROM period_selection WHERE OPERATING IS TRUE);
    IF (NEW.operating IS TRUE AND :true_count > 0) THEN
        EXCEPTION period_exception 'Выбрано больше одного текущего периода!
        ';
END

^

CREATE TRIGGER POKAZANIE_CHECK FOR POKAZANIE
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
DECLARE VARIABLE schetchik_nachalo TYPE OF COLUMN schetchik.nachalo;
DECLARE VARIABLE perv_pokaz TYPE OF COLUMN pokazanie.pokaz;
DECLARE VARIABLE pred_pokaz TYPE OF COLUMN pokazanie.pokaz;
DECLARE VARIABLE sled_pokaz TYPE OF COLUMN pokazanie.pokaz;
BEGIN
    :schetchik_nachalo = (SELECT NACHALO FROM schetchik WHERE ID = NEW.id_schetchik);
    :perv_pokaz = (SELECT PERV_POKAZ FROM schetchik WHERE ID = NEW.id_schetchik);
    :pred_pokaz = (SELECT POKAZ FROM pokazanie
    WHERE ID_SCHETCHIK = NEW.id_schetchik AND PERIOD =
    -- выбор наиближайшего к периоду показания снизу
    (SELECT MAX(PERIOD) FROM pokazanie
    WHERE ID_SCHETCHIK = NEW.id_schetchik AND
    -- отсечение показаний за период <= начала действия счетчика
    (PERIOD > :schetchik_nachalo AND PERIOD < NEW.period)));
    :sled_pokaz = (SELECT POKAZ FROM pokazanie
    WHERE ID_SCHETCHIK = NEW.id_schetchik AND PERIOD =
    -- выбор наиближайшего к периоду показания сверху
    (SELECT MIN(PERIOD) FROM pokazanie
    WHERE ID_SCHETCHIK = NEW.id_schetchik AND PERIOD > NEW.period));
    IF (NEW.period <= :schetchik_nachalo) THEN
        EXCEPTION pokazanie_exception 'Период показания должен быть позже начала действия счетчика!
        ';
    IF (NEW.pokaz < :perv_pokaz) THEN
        EXCEPTION pokazanie_exception 'Введенное показание меньше первоначального!
        ';
    IF (NEW.pokaz < :pred_pokaz) THEN
        EXCEPTION pokazanie_exception 'Введенное показание меньше предыдущего!
        ';
    IF (NEW.pokaz > :sled_pokaz) THEN
        EXCEPTION pokazanie_exception 'Введенное показание больше следующего!
        ';
END

^

CREATE TRIGGER SERV_UCH_DIS_CHANGED FOR SERV_UCH_DISABLE
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  NEW.CHANGED = CURRENT_DATE ;
end

^

CREATE TRIGGER TARIF_CHANGED FOR TARIF
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  NEW.CHANGED = CURRENT_DATE ;
end

^

SET TERM ; ^

/******************************************************************************/
/***                               Procedures                               ***/
/******************************************************************************/

SET TERM ^ ;

SET TERM ; ^



/******************************************************************************/
/***                          Object descriptions                           ***/
/******************************************************************************/



/* Procedures and Internal Functions */

SET TERM ^ ;

CREATE OR ALTER FUNCTION param_znachenie (
    id_parametr TYPE OF COLUMN param_global.id,
    id_uchastok TYPE OF COLUMN uchastok.id NOT NULL,
    period TYPE OF COLUMN nachislenie.period NOT NULL)
RETURNS TYPE OF COLUMN param_global.znachenie
AS
DECLARE VARIABLE param_nachalo TYPE OF COLUMN param_global.nachalo;
BEGIN
    IF (:id_parametr IS NOT NULL) THEN
        IF ((SELECT GLOBAL_ FROM parametr WHERE ID = :id_parametr) IS TRUE) THEN
        BEGIN
            :param_nachalo = (SELECT MAX(NACHALO) FROM param_global
            WHERE ID_PARAMETR = :id_parametr AND NACHALO <= :period);
            IF (:param_nachalo IS NOT NULL) THEN
                RETURN (SELECT ZNACHENIE FROM param_global
                WHERE ID_PARAMETR = :id_parametr AND NACHALO = :param_nachalo);
            ELSE
                EXCEPTION raschet_exception
                    'Не установлено участвующее в расчете значение глобального параметра "' || (SELECT NAME FROM parametr WHERE ID = :id_parametr) || '" для периода "' || :period || '". Операция отменена.
                    ';
        END
        ELSE
        BEGIN
            :param_nachalo = (SELECT MAX(NACHALO) FROM param_uch
            WHERE ID_PARAMETR = :id_parametr AND
            ID_UCHASTOK = :id_uchastok AND NACHALO <= :period);
            IF (:param_nachalo IS NOT NULL) THEN
                RETURN (SELECT ZNACHENIE FROM param_uch
                WHERE ID_PARAMETR = :id_parametr AND
                ID_UCHASTOK = :id_uchastok AND NACHALO = :param_nachalo);
            ELSE
                RETURN 0;
        END
    ELSE
        RETURN NULL;
END
^

CREATE OR ALTER FUNCTION nachis (
    id_uchastok TYPE OF COLUMN uchastok.id NOT NULL,
    id_service TYPE OF COLUMN service.id NOT NULL,
    period TYPE OF COLUMN nachislenie.period NOT NULL,
    tarif_ TYPE OF COLUMN tarif.znachenie NOT NULL)
RETURNS TYPE OF COLUMN nachislenie.nachis NOT NULL
AS
DECLARE VARIABLE result_schetchik DECIMAL(9,2) NOT NULL = 0;
DECLARE VARIABLE result_param DECIMAL(18,3) NOT NULL = 0;
DECLARE VARIABLE schetchik_ TYPE OF COLUMN service.schetchik_;
DECLARE VARIABLE for_id_sch TYPE OF COLUMN schetchik.id;
DECLARE VARIABLE for_pokaz TYPE OF COLUMN pokazanie.pokaz;
DECLARE VARIABLE pred_pokaz TYPE OF COLUMN schetchik.perv_pokaz;
DECLARE VARIABLE rashod TYPE OF COLUMN pokazanie.pokaz;
DECLARE VARIABLE s_uch TYPE OF COLUMN service.s_uch;
DECLARE VARIABLE parametr_1 TYPE OF COLUMN param_global.znachenie;
DECLARE VARIABLE parametr_2 TYPE OF COLUMN param_global.znachenie;
DECLARE VARIABLE parametr_3 TYPE OF COLUMN param_global.znachenie;
DECLARE VARIABLE parametr_4 TYPE OF COLUMN param_global.znachenie;
DECLARE VARIABLE operator_1 TYPE OF COLUMN service.operator_1;
DECLARE VARIABLE operator_2 TYPE OF COLUMN service.operator_2;
DECLARE VARIABLE operator_3 TYPE OF COLUMN service.operator_3;
DECLARE VARIABLE operator_4 TYPE OF COLUMN service.operator_4;
DECLARE VARIABLE n_uch TYPE OF COLUMN uchastok.n;
DECLARE VARIABLE name_serv TYPE OF COLUMN service.name;

DECLARE FUNCTION get_result
(param TYPE OF COLUMN param_global.znachenie,
operator TYPE OF COLUMN service.operator_1,
result DECIMAL(18,3))
RETURNS DECIMAL(18,3)
AS
BEGIN
RETURN CASE
WHEN :operator = 1 THEN :result + :param
WHEN :operator = 2 THEN :result - :param
WHEN :operator = 3 THEN :result * :param
WHEN :operator = 4 AND :param != 0 THEN :result / :param
ELSE 0
END;
END


BEGIN
    :schetchik_ = (SELECT SCHETCHIK_ FROM service WHERE ID = :id_service);
    IF (:schetchik_ IS TRUE) THEN
    -- расчет по счетчикам
    BEGIN
        -- проход по всем имеющимся показаниям в периоде
        FOR SELECT ID_SCHETCHIK, POKAZ FROM pokazanie WHERE ID_SCHETCHIK IN (
        /* список имеющихся и действующих счетчиков в периоде
        (период строго больше начала действия счетчика) */
        SELECT ID FROM schetchik WHERE ID_UCHASTOK = :id_uchastok AND
        ID_SERVICE = :id_service AND NACHALO < :period AND
        (KONEC IS NULL OR KONEC >= :period)
        ) AND PERIOD = :period INTO :for_id_sch, :for_pokaz
        DO
        BEGIN
            :pred_pokaz = (SELECT POKAZ FROM pokazanie
            WHERE ID_SCHETCHIK = :for_id_sch AND PERIOD =
            -- выбор наиближайшего к периоду показания
            (SELECT MAX(PERIOD) FROM pokazanie
            WHERE ID_SCHETCHIK = :for_id_sch AND
            -- отсечение показаний за период <= начала действия счетчика
            (PERIOD > (SELECT NACHALO FROM schetchik WHERE ID = :for_id_sch) AND
            PERIOD < :period)));
            IF (:pred_pokaz IS NOT NULL) THEN
                :rashod = :for_pokaz - :pred_pokaz;
            ELSE
                :rashod = :for_pokaz - (SELECT PERV_POKAZ FROM schetchik
                WHERE ID = :for_id_sch);
            -- отрицательный расход не учитывается (0)
            IF (:rashod >= 0) THEN
                :result_schetchik = :result_schetchik + :rashod;
        END
        /* если есть хотя бы одно показание, то расчет по счетчику,
        иначе спускаемся дальше и выполняем расчет по параметрам */
        IF (:for_pokaz IS NOT NULL) THEN
            RETURN :result_schetchik * :tarif_;
    END
    -- расчет по параметрам
    /* чем больше масштаб переменной :result_param, тем выше точность вычисления
    и тем выше вероятность возникновения ошибки переполнения */
    :s_uch = (SELECT S_UCH FROM service WHERE ID = :id_service);
    /* Поведение функции PARAM_ZNACHENIE:
    - возврат NULL - если параметр не задействован для взноса (ID_PARAMETR_# IS NULL),
    - исключение - если задействован глобальный параметр и отсутствует его значение для выбранного периода
    - возврат 0 - если задействован параметра участка и отсутствует его значение для выбранного периода */
    :parametr_1 = PARAM_ZNACHENIE(
    (SELECT ID_PARAMETR_1 FROM service WHERE ID = :id_service), :id_uchastok, :period);
    :parametr_2 = PARAM_ZNACHENIE(
    (SELECT ID_PARAMETR_2 FROM service WHERE ID = :id_service), :id_uchastok, :period);
    :parametr_3 = PARAM_ZNACHENIE(
    (SELECT ID_PARAMETR_3 FROM service WHERE ID = :id_service), :id_uchastok, :period);
    :parametr_4 = PARAM_ZNACHENIE(
    (SELECT ID_PARAMETR_4 FROM service WHERE ID = :id_service), :id_uchastok, :period);
    :operator_1 = (SELECT OPERATOR_1 FROM service WHERE ID = :id_service);
    :operator_2 = (SELECT OPERATOR_2 FROM service WHERE ID = :id_service);
    :operator_3 = (SELECT OPERATOR_3 FROM service WHERE ID = :id_service);
    :operator_4 = (SELECT OPERATOR_4 FROM service WHERE ID = :id_service);
    :n_uch = (SELECT N FROM uchastok WHERE ID = :id_uchastok);
    :name_serv = (SELECT NAME FROM service WHERE ID = :id_service);
    IF (:s_uch IS TRUE) THEN
        :result_param = (SELECT S FROM uchastok WHERE ID = :id_uchastok);
    IF (:parametr_1 IS NOT NULL) THEN
    BEGIN
        IF (:s_uch IS TRUE) THEN
            :result_param = get_result(:parametr_1, :operator_1, result_param);
        ELSE
            :result_param = :parametr_1;
        IF (:parametr_2 IS NOT NULL) THEN
        BEGIN
            :result_param = get_result(:parametr_2, :operator_2, result_param);
            IF (:parametr_3 IS NOT NULL) THEN
            BEGIN
                :result_param = get_result(:parametr_3, :operator_3, result_param);
                IF (:parametr_4 IS NOT NULL) THEN
                    :result_param = get_result(:parametr_4, :operator_4, result_param);
            END
        END
    END
    IF (:result_param < 0) THEN
        EXCEPTION raschet_exception
            'Результат расчета для взноса "' || :name_serv || '" для участка № ' || :n_uch || ' за период "' || :period || '" - отрицательное число. Операция отменена. Проверьте расчетные параметры данного взноса.
            ';
    RETURN :result_param * :tarif_;
    /* вероятность возникновения ошибки arith_except,
    когда переменная :result_param не может принять результат, низка,
    поскольку прежде в большинстве случаев возникнет exception_integer_overflow,
    когда невозможно выполнить арифметическую операцию из-за переполнения */
    WHEN GDSCODE exception_integer_overflow, GDSCODE arith_except DO
        EXCEPTION raschet_exception
            'При расчете взноса "' || :name_serv || '" для участка № ' || :n_uch || ' возникла ошибка переполнения! Операция отменена. Уменьшите значения расчетных параметров данного взноса в периоде "' || :period || '".
            ';
END
^

CREATE OR ALTER PROCEDURE delete_and_insert_nachislenie (
    id_uchastok TYPE OF COLUMN uchastok.id NOT NULL,
    id_service TYPE OF COLUMN service.id NOT NULL,
    period TYPE OF COLUMN nachislenie.period NOT NULL)
AS
DECLARE VARIABLE current_id TYPE OF COLUMN nachislenie.id;
DECLARE VARIABLE current_izmenenie TYPE OF COLUMN nachislenie.izmenenie;
DECLARE VARIABLE uchastok_nachalo TYPE OF COLUMN nachislenie.period;
DECLARE VARIABLE uchastok_konec TYPE OF COLUMN nachislenie.period;
DECLARE VARIABLE service_nachalo TYPE OF COLUMN nachislenie.period;
DECLARE VARIABLE service_konec TYPE OF COLUMN nachislenie.period;
DECLARE VARIABLE serv_uch_dis_nachalo TYPE OF COLUMN nachislenie.period;
DECLARE VARIABLE tarif_nachalo TYPE OF COLUMN nachislenie.period;
DECLARE VARIABLE tarif_znachenie TYPE OF COLUMN tarif.znachenie;
BEGIN
    /* запоминание текущего ID строки в таблице nachislenie,
    чтобы использовать его при вставке, с целью не использовать автоинкремент
    всегда когда это возможно, иначе возможно быстрое переполнение ID */
    :current_id = (SELECT ID FROM nachislenie WHERE PERIOD = :period AND
    ID_UCHASTOK = :id_uchastok AND ID_SERVICE = :id_service);
    :current_izmenenie = (SELECT IZMENENIE FROM nachislenie WHERE PERIOD = :period AND
    ID_UCHASTOK = :id_uchastok AND ID_SERVICE = :id_service);
    -- удаление строки по входным параметрам, если она существует, перед вставкой
    DELETE FROM nachislenie WHERE PERIOD = :period AND
    ID_UCHASTOK = :id_uchastok AND ID_SERVICE = :id_service;
    :uchastok_nachalo = (SELECT NACHALO FROM uchastok WHERE ID = :id_uchastok);
    :uchastok_konec = (SELECT KONEC FROM uchastok WHERE ID = :id_uchastok);
    :service_nachalo = (SELECT NACHALO FROM service WHERE ID = :id_service);
    :service_konec = (SELECT KONEC FROM service WHERE ID = :id_service);
    :serv_uch_dis_nachalo = (SELECT MAX(NACHALO) FROM serv_uch_disable
    WHERE ID_UCHASTOK = :id_uchastok AND ID_SERVICE = :id_service AND NACHALO <= :period);
    :tarif_nachalo = (SELECT MAX(NACHALO) FROM tarif
    WHERE ID_SERVICE = :id_service AND NACHALO <= :period);
    -- проверки для выбранного периода:
    -- проверка периода действия участка
    IF ((:period >= :uchastok_nachalo) AND
    (:uchastok_konec IS NULL OR :period <= :uchastok_konec)) THEN
        -- проверка периода действия взноса
        IF ((:period >= :service_nachalo) AND
        (:service_konec IS NULL OR :period <= service_konec)) THEN
            -- проверка на действительность взноса в участке
            IF (:serv_uch_dis_nachalo IS NULL OR (SELECT DISABLE FROM serv_uch_disable
            WHERE ID_UCHASTOK = :id_uchastok AND ID_SERVICE = :id_service AND
            NACHALO = :serv_uch_dis_nachalo) IS FALSE) THEN
                -- проверка на наличие тарифа для взноса
                IF (:tarif_nachalo IS NOT NULL) THEN
                BEGIN
                    :tarif_znachenie = (SELECT ZNACHENIE FROM tarif
                    WHERE ID_SERVICE = :id_service AND NACHALO = :tarif_nachalo);
                    IF (:current_id IS NOT NULL) THEN
                        INSERT INTO nachislenie (ID, ID_UCHASTOK, ID_SERVICE, PERIOD, IZMENENIE, NACHIS)
                        VALUES (:current_id, :id_uchastok, :id_service, :period, :current_izmenenie,
                        NACHIS(:id_uchastok, :id_service, :period, :tarif_znachenie));
                    ELSE
                        INSERT INTO nachislenie (ID_UCHASTOK, ID_SERVICE, PERIOD, NACHIS)
                        VALUES (:id_uchastok, :id_service, :period,
                        NACHIS(:id_uchastok, :id_service, :period, :tarif_znachenie));
                END
                ELSE
                    EXCEPTION raschet_exception
                        'Нет действующего в периоде "' || :period || '" тарифа для взноса "' || (SELECT NAME FROM service WHERE ID = :id_service) || '". Операция отменена.
                        ';
END
^

CREATE OR ALTER PROCEDURE raschet (
    period TYPE OF COLUMN nachislenie.period NOT NULL,
    id_uchastok TYPE OF COLUMN uchastok.id,
    id_service TYPE OF COLUMN service.id)
AS
DECLARE VARIABLE for_period TYPE OF COLUMN nachislenie.period;
DECLARE VARIABLE for_id_uch TYPE OF COLUMN uchastok.id;
DECLARE VARIABLE for_id_serv TYPE OF COLUMN service.id;
BEGIN
    FOR SELECT PERIOD FROM period_selection WHERE PERIOD >= :period AND
    PERIOD <= (SELECT PERIOD FROM period_selection WHERE OPERATING IS TRUE) INTO :for_period
    DO
    BEGIN
      IF (:id_uchastok IS NOT NULL AND :id_service IS NOT NULL) THEN
        EXECUTE PROCEDURE DELETE_AND_INSERT_NACHISLENIE(:id_uchastok, :id_service, :for_period);
      ELSE
      BEGIN
        IF (:id_uchastok IS NULL AND :id_service IS NOT NULL) THEN
            FOR SELECT ID FROM uchastok INTO :for_id_uch
            -- если нет участков, то блок DO не выполняется
            DO
            EXECUTE PROCEDURE DELETE_AND_INSERT_NACHISLENIE(:for_id_uch, :id_service, :for_period);
        IF (:id_service IS NULL AND :id_uchastok IS NOT NULL) THEN
            FOR SELECT ID FROM service INTO :for_id_serv
            -- если нет взносов, то блок DO не выполняется
            DO
            EXECUTE PROCEDURE DELETE_AND_INSERT_NACHISLENIE(:id_uchastok, :for_id_serv, :for_period);
        IF (:id_service IS NULL AND :id_uchastok IS NULL) THEN
            FOR SELECT ID FROM service INTO :for_id_serv
            DO
                FOR SELECT ID FROM uchastok INTO :for_id_uch
                DO
                EXECUTE PROCEDURE DELETE_AND_INSERT_NACHISLENIE(:for_id_uch, :for_id_serv, :for_period);
      END
    END
    IF (:for_period IS NULL) THEN
        EXCEPTION raschet_exception
            'Выбранный период "' || :period || '" позже действующего периода или действующий период не установлен. Операция отменена.
            ';
END
^

CREATE OR ALTER PROCEDURE sum_itog (
    id TYPE OF COLUMN uchastok.id NOT NULL)
RETURNS (
    id_uchastok TYPE OF COLUMN uchastok.id,
    period TYPE OF COLUMN nachislenie.period,
    dolg TYPE OF COLUMN nachislenie.k_oplate,
    k_oplate TYPE OF COLUMN nachislenie.k_oplate,
    itogo_k_oplate TYPE OF COLUMN nachislenie.k_oplate,
    oplacheno TYPE OF COLUMN oplata.summa,
    itogo_dolg TYPE OF COLUMN nachislenie.k_oplate)
AS
DECLARE VARIABLE current_period TYPE OF COLUMN nachislenie.period;
BEGIN
    :current_period = (SELECT PERIOD FROM period_selection WHERE OPERATING IS TRUE);
    FOR
        WITH cte_nachislenie AS
        (SELECT ID_UCHASTOK, PERIOD, SUM(K_OPLATE) AS K_OPLATE
        FROM nachislenie WHERE ID_UCHASTOK = :id AND
        PERIOD <= :current_period GROUP BY ID_UCHASTOK, PERIOD),
        cte_oplata AS
        (SELECT ID_UCHASTOK, SUM(SUMMA) AS SUMMA, PERIOD
        FROM oplata WHERE ID_UCHASTOK = :id AND
        PERIOD <= :current_period GROUP BY ID_UCHASTOK, PERIOD),
        cte_period_selection AS
        (SELECT PERIOD FROM period_selection WHERE PERIOD <= :current_period),
        cte_opl_nach_period AS
        (SELECT COALESCE(cte_nachislenie.ID_UCHASTOK, cte_oplata.ID_UCHASTOK, :id) AS ID_UCHASTOK,
        COALESCE(cte_nachislenie.PERIOD, cte_oplata.PERIOD, cte_period_selection.PERIOD) AS PERIOD,
        (SELECT COALESCE(SUM(K_OPLATE), 0) FROM nachislenie
        WHERE PERIOD < COALESCE(cte_nachislenie.PERIOD, cte_oplata.PERIOD, cte_period_selection.PERIOD) AND
        ID_UCHASTOK = :id) - (SELECT COALESCE(SUM(SUMMA), 0) FROM oplata
        WHERE PERIOD < COALESCE(cte_nachislenie.PERIOD, cte_oplata.PERIOD, cte_period_selection.PERIOD) AND
        ID_UCHASTOK = :id) AS DOLG,
        COALESCE(K_OPLATE, 0) AS K_OPLATE, COALESCE(SUMMA, 0) AS OPLACHENO
        FROM cte_nachislenie FULL OUTER JOIN cte_oplata ON
        cte_nachislenie.PERIOD = cte_oplata.PERIOD FULL OUTER JOIN cte_period_selection ON
        COALESCE(cte_nachislenie.PERIOD, cte_oplata.PERIOD) = cte_period_selection.PERIOD)
        SELECT ID_UCHASTOK, PERIOD, DOLG, K_OPLATE, (DOLG + K_OPLATE) AS ITOGO_K_OPLATE,
        OPLACHENO, (DOLG + K_OPLATE - OPLACHENO) AS ITOGO_DOLG FROM cte_opl_nach_period
        ORDER BY PERIOD DESC
        INTO :id_uchastok, :period, :dolg, :k_oplate, :itogo_k_oplate, :oplacheno, :itogo_dolg
    DO
    BEGIN
        SUSPEND;
    END
END
^

CREATE OR ALTER PROCEDURE global_sum_itog
RETURNS (
    n TYPE OF COLUMN uchastok.n,
    alleya TYPE OF COLUMN uchastok.alleya,
    period TYPE OF COLUMN nachislenie.period,
    dolg TYPE OF COLUMN nachislenie.k_oplate,
    k_oplate TYPE OF COLUMN nachislenie.k_oplate,
    itogo_k_oplate TYPE OF COLUMN nachislenie.k_oplate,
    oplacheno TYPE OF COLUMN oplata.summa,
    itogo_dolg TYPE OF COLUMN nachislenie.k_oplate)
AS
DECLARE VARIABLE current_period TYPE OF COLUMN nachislenie.period;
DECLARE VARIABLE for_id TYPE OF COLUMN uchastok.id;
DECLARE VARIABLE for_n TYPE OF COLUMN uchastok.n;
DECLARE VARIABLE for_alleya TYPE OF COLUMN uchastok.alleya;
BEGIN 
    :current_period = (SELECT PERIOD FROM period_selection WHERE OPERATING IS TRUE);
    FOR SELECT ID, N, ALLEYA FROM uchastok WHERE KONEC IS NULL OR KONEC >= :current_period
    INTO :for_id, :for_n, :for_alleya
    DO
    BEGIN
        SELECT :for_n, :for_alleya, PERIOD, DOLG, K_OPLATE, ITOGO_K_OPLATE, OPLACHENO, ITOGO_DOLG
        FROM sum_itog(:for_id) WHERE PERIOD = :current_period
        INTO :n, :alleya, :period, :dolg, :k_oplate, :itogo_k_oplate, :oplacheno, :itogo_dolg;
        SUSPEND;
    END
END
^

SET TERM ; ^


/* Views */

CREATE OR ALTER VIEW CURRENT_DOLG(
    N,
    ALLEYA,
    DOLG,
    K_OPLATE,
    ITOGO_K_OPLATE,
    OPLACHENO,
    ITOGO_DOLG)
AS
SELECT N, ALLEYA, DOLG, K_OPLATE, ITOGO_K_OPLATE, OPLACHENO, ITOGO_DOLG FROM global_sum_itog
UNION
SELECT NULL, 'Итого:', SUM(DOLG), SUM(K_OPLATE), SUM(ITOGO_K_OPLATE), SUM(OPLACHENO), SUM(ITOGO_DOLG) FROM global_sum_itog
ORDER BY 2, 1
;

CREATE OR ALTER VIEW OWNERS(
    FAMILIYA,
    IMYA,
    OTCHESTVO,
    PHONE,
    EMAIL,
    ADDRESS,
    N,
    DOCUMENT,
    DOLYA,
    DATA_IN)
AS
SELECT FAMILIYA, IMYA, OTCHESTVO, PHONE, EMAIL, ADDRESS,
LIST(N || ' / ' || COALESCE(ALLEYA, '-'), ', ') AS N,
LIST(DOCUMENT, ', ') AS DOCUMENT, LIST(DOLYA, ', ') AS DOLYA,
LIST(DATA_IN, ', ') AS DATA_IN FROM sobstvennik
JOIN sobstv_uch ON sobstvennik.ID = ID_SOBSTVENNIK
JOIN uchastok ON ID_UCHASTOK = uchastok.ID
WHERE DATA_OUT IS NULL
GROUP BY FAMILIYA, IMYA, OTCHESTVO, PHONE, EMAIL, ADDRESS
ORDER BY FAMILIYA
;